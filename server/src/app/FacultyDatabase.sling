import jk.log
import jk.sqlite
import jk.mysql
import jk.sql
import jk.env
import jk.time

class:

model Info
{
    id as string
    firstname as string
    lastname as string
    contactnumber as string
    address as string
    username as string
    password as string
    firstnamedeceased as string
    lastnamedeceased as string
    currentdate as string
    burialdate as string
    servicetype as string
    serviceprice as string
    lotnumber as string
    timeStampAdded as long
    timeStampLastUpdated as long
}
model Login
{
    id as string
    fullname as string
    gender as string
    username as string
    password as string
    timeStampAdded as long
    timeStampLastUpdated as long
}



    const INFO = "info"
    const LOGIN = "login"
    pvar db as MySQLDatabase


func forContext(ctx as LoggingContext) static as this
{
    var cstr = EnvironmentVariable.get("FacultyDatabase")
    Log.debug(ctx, "Opening database connection: " .. cstr .. "'")
    db = MySQLDatabase.forConnectionStringSync(ctx, cstr)
    if not db:
        Error.throw("failedToConnectionToDatabase", cstr)
    var v = new this()
    v.setDb(db)
    return v
}


func updateTable(table as SQLTableInfo)
{
    if not table:
        Error.throw("nullTable", "updateTable")
    if not db:
        Error.throw("nullDB","updateTable")
    if not db.ensureTableExistsSync(table):
        Error.throw("failedToUpdateTable", table.getName())

}

func updateInfoTables
{
    var info = SQLTableInfo.forName(INFO)
    info.addStringKeyColumn("id")
    info.addStringColumn("firstname")
    info.addStringColumn("lastname")
    info.addStringColumn("contactnumber")
    info.addStringColumn("address")
    info.addStringColumn("username")
    info.addStringColumn("password")
    info.addStringColumn("firstnamedeceased")
    info.addStringColumn("lastnamedeceased")
    info.addStringColumn("currentdate")
    info.addStringColumn("burialdate")
    info.addStringColumn("servicetype")
    info.addStringColumn("serviceprice")
    info.addStringColumn("lotnumber")
    info.addLongColumn("timeStampAdded")
    info.addLongColumn("timeStampLastUpdated")
    updateTable(info)
}

func updateLoginTables
{
    var login = SQLTableInfo.forName(LOGIN)
    login.addStringKeyColumn("id")
    login.addStringColumn("fullname")
    login.addStringColumn("gender")
    login.addStringColumn("username")
    login.addStringColumn("password")
    login.addLongColumn("timeStampAdded")
    login.addLongColumn("timeStampLastUpdated")
    updateTable(login)
}




func addInfo(info as Info) as Info
{
    assert info
    info.setId("1")
    info.setTimeStampAddedValue(SystemClock.asUTCSeconds())
    assert db.executeSync(db.prepareInsertStatementSync(INFO, info.toDynamicMap()))
    return info

}

func updateInfo(id as string, info as Info) as bool
{
    assert info
    info.setTimeStampLastUpdatedValue(SystemClock.asUTCSeconds())
    var criteria = new Info()
    criteria.setId(id)
    return db.executeSync(db.prepareUpdateStatementSync(INFO, criteria.toDynamicMap(), info.toDynamicMap()))
}

func deleteInfo(id as string) as bool
{
    var criteria = new Info()
    criteria.setId(id)
    return db.executeSync(db.prepareDeleteStatementSync(INFO, criteria.toDynamicMap()))
}


func getInfo as DynamicMap
{
    var v = new vector<Info>
    var it = assert db.querySync(db.prepareQueryAllStatementSync(INFO)):
        return null
    while it {
        var o = it.next()
        if not o:
            break
        var info = Info.forJsonObject(o)
        if not info:
            continue
        v += info

    }
    var data = new DynamicMap()
    data.setObject("records", v)
    return data

}

func addlogin(login as Login) as Login
{
    assert login
    login.setId("1")
    login.setTimeStampAddedValue(SystemClock.asUTCSeconds())
    assert db.executeSync(db.prepareInsertStatementSync(LOGIN, login.toDynamicMap()))
    return login

}

func updateLogin(id as string, login as Login) as bool
{
    assert login
    login.setTimeStampLastUpdatedValue(SystemClock.asUTCSeconds())
    var criteria = new Login()
    criteria.setId(id)
    return db.executeSync(db.prepareUpdateStatementSync(LOGIN, criteria.toDynamicMap(), login.toDynamicMap()))
}

func deleteLogin(id as string) as bool
{
    var criteria = new Login()
    criteria.setId(id)
    return db.executeSync(db.prepareDeleteStatementSync(LOGIN, criteria.toDynamicMap()))
}


func getLogin as DynamicMap
{
    var v = new vector<Login>
    var it = assert db.querySync(db.prepareQueryAllStatementSync(LOGIN)):
        return null
    while it {
        var o = it.next()
        if not o:
            break
        var login = Login.forJsonObject(o)
        if not login:
            continue
        v += login

    }
    var data = new DynamicMap()
    data.setObject("records", v)
    return data

}

func close
{
    if db:
        db.closeSync()
    db = null
}

